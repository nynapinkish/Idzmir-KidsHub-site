<!doctype html>
<html lang="ms">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SPIN & SAY â€” Fillable SVG Demo</title>

  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;800&display=swap" rel="stylesheet">

  <style>
    /* ---------- CSS (trimmed + kept original styling) ---------- */
    * { margin:0; padding:0; box-sizing:border-box; }
    body { font-family:'Poppins',sans-serif; background:#f8fafc; min-height:100vh; padding:24px; }
    .header { background:#003e8d; color:#fff; padding:12px 20px; border-radius:12px; margin-bottom:18px; display:flex; justify-content:space-between; align-items:center; }
    .title-box { background: linear-gradient(#ffd032,#ffc107); padding:12px 20px; border-radius:9999px; display:inline-block; box-shadow:0 6px 18px rgba(0,61,130,0.18);}
    .title-box h1 { margin:0; color:#003e8d; font-size:28px; }
    .main-content { display:grid; grid-template-columns:220px 1fr 300px; gap:24px; align-items:start; max-width:1200px; margin:20px auto; }

    /* Left color picker */
    .color-picker { background:#fff; border-radius:16px; padding:18px; box-shadow:0 6px 18px rgba(0,0,0,0.06); }
    .selected-color-circle { width:100px; height:100px; border-radius:50%; margin:0 auto 8px; border:5px solid #fff; box-shadow:0 8px 24px rgba(0,0,0,0.08); }
    .color-label { text-align:center; margin-top:6px; font-size:12px; color:#374151; font-weight:600; text-transform:uppercase; }
    .palette-buttons { display:flex; flex-wrap:wrap; gap:8px; justify-content:center; margin:10px 0 14px; }
    .palette-btn { padding:6px 10px; border-radius:999px; border:none; cursor:pointer; font-weight:600; font-size:12px; }
    .palette-btn.active { background:#2563eb;color:#fff; transform:scale(1.03); }
    .color-grid { display:grid; grid-template-columns:repeat(4,1fr); gap:12px; margin-bottom:14px; }
    .color-btn { width:48px; height:48px; border-radius:10px; border:none; cursor:pointer; box-shadow:0 3px 10px rgba(0,0,0,0.08); }
    .quick-colors-grid { display:flex; gap:8px; justify-content:center; margin-top:8px; }
    .quick-color-btn { width:36px; height:36px; border-radius:50%; border:none; cursor:pointer; box-shadow:0 3px 8px rgba(0,0,0,0.08); }
    .reset-btn { width:100%; margin-top:12px; padding:10px; border-radius:10px; border:none; background:linear-gradient(90deg,#ef4444,#ec4899); color:#fff; cursor:pointer; font-weight:700; }

    /* Wheel area */
    .wheel-section { background:#fff; border-radius:16px; padding:24px; display:flex; justify-content:center; align-items:center; box-shadow:0 6px 18px rgba(0,0,0,0.06); min-height:360px; }
    #customSvgContainer { position:relative; width:260px; height:320px; }

    /* Answer grid (right) */
    .answer-panel { background:#fff; border-radius:16px; padding:18px; box-shadow:0 6px 18px rgba(0,0,0,0.06); }
    .answer-grid { display:grid; grid-template-columns:repeat(2,1fr); gap:18px; margin-top:8px; }
    .answer-btn { width:120px; height:120px; border-radius:9999px; font-size:36px; font-weight:800; border:5px solid #111827; background:#fff; cursor:pointer; display:flex; align-items:center; justify-content:center; }
    .answer-btn.correct { background:#4ade80; border-color:#16a34a; box-shadow:0 0 24px rgba(34,197,94,0.5); }
    .answer-btn.incorrect { background:#f87171; border-color:#dc2626; box-shadow:0 0 24px rgba(239,68,68,0.5); }

    /* Next button */
    .next-button { position:fixed; right:32px; bottom:32px; }
    .next-btn { padding:12px 20px; border-radius:999px; border:none; background:linear-gradient(90deg,#4ade80,#3b82f6); color:#fff; font-weight:800; cursor:pointer; box-shadow:0 10px 30px rgba(0,0,0,0.18); }

    /* small helpers */
    .center { display:flex; justify-content:center; align-items:center; gap:8px; flex-direction:column; }
  </style>
</head>
<body>
  <header class="header">
    <div class="title-box"><h1>SPIN & SAY</h1></div>
    <div style="color:#fff;font-weight:600;">Idzmir Kids Hub</div>
  </header>

  <main class="main-content" style="margin-top:18px;">
    <!-- Left: Color picker -->
    <aside class="color-picker">
      <div class="center">
        <div id="selectedColorCircle" class="selected-color-circle"></div>
        <div class="color-label">Selected Color</div>
      </div>

      <div style="margin-top:12px;">
        <h4 style="text-align:center;margin:8px 0 6px;color:#374151;">Choose Palette</h4>
        <div id="paletteButtons" class="palette-buttons"></div>
      </div>

      <div id="colorGrid" class="color-grid"></div>

      <div style="margin-top:8px;">
        <h4 style="text-align:center;margin:6px 0;color:#374151;">Quick Pick</h4>
        <div id="quickColors" class="quick-colors-grid"></div>
      </div>

      <button class="reset-btn" onclick="resetGame()">ðŸ”„ Reset</button>
    </aside>

    <!-- Middle: Wheel / SVG -->
    <section class="wheel-section">
      <div id="customSvgContainer"></div>
    </section>

    <!-- Right: Answers -->
    <aside class="answer-panel">
      <div style="font-weight:700;color:#374151;margin-bottom:8px;">Answers</div>
      <div id="answerGrid" class="answer-grid"></div>
    </aside>
  </main>

  <div class="next-button">
    <button class="next-btn" onclick="handleNextLevel()">NEXT</button>
  </div>

  <!-- ----------------- JS (game logic) ----------------- -->
  <script>
  // ================== GAME LOGIC ==================
  let selectedColor = '#FF6B6B';
  let feedback = {};
  let currentNumber = 0;
  let fillProgress = 0;
  const fillSteps = 10;
  let currentSvgElement = null; // Store reference to current SVG
  let currentSvgClickHandler = null;

  // ================== SVG IMAGE PATHS ==================
  const svgPaths = {
    0: '../../../../assets/images/svg/zero.svg',   // <-- pastikan path betul di projek kamu
    1: 'assets/svg/one.svg',
    2: 'assets/svg/two.svg',
    3: 'assets/svg/three.svg'
  };

  // ================== COLOR PALETTES ==================
  const colorPalettes = {
    vibrant: ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E2'],
    pastel: ['#FFB6C1', '#E0BBE4', '#FFDAB9', '#B0E0E6', '#DDA0DD', '#F0E68C', '#98FB98', '#FFC0CB'],
    rainbow: ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#9400D3', '#FF1493'],
    ocean: ['#006994', '#0FA3B1', '#1E88E5', '#42A5F5', '#64B5F6', '#90CAF9', '#00BCD4', '#26C6DA'],
    sunset: ['#FF6F61', '#FFB347', '#FFD700', '#FF8C42', '#E74C3C', '#FF6B9D', '#FFA07A', '#FF69B4']
  };
  let currentPalette = 'vibrant';

  // ================== FLYING OPTIONS (answers) ==================
  const flyingOptions = {
    0: [0,0,0,0,0,0,0,0,0,0],
    1: [3,8,1,3,0,5,4,3,0,0],
    2: [2,7,4,1,6,3,5,1,8,0],
    3: [5,4,2,7,2,6,1,4,3,2]
  };

  // ================== INIT ==================
  function init() {
    renderPaletteButtons();
    renderColorGrid();
    renderQuickColors();
    renderAnswerButtons();
    updateSelectedColor(); // sets selected color circle
    updateCenterSvg();
  }

  // ================== SELECTED COLOR ==================
  function updateSelectedColor() {
    const circle = document.getElementById('selectedColorCircle');
    circle.style.backgroundColor = selectedColor;
    circle.style.boxShadow = `0 10px 40px ${selectedColor}40`;

    // Update gradient stop color in current svg if exists
    if (currentSvgElement) {
      const fillStop = currentSvgElement.querySelector(`#fillColorStop-${currentNumber}`);
      if (fillStop) fillStop.setAttribute('stop-color', selectedColor);
      // Also update immediately so visual matches
      updateSvgFill(currentSvgElement, fillProgress);
    }
  }

  // ================== PALETTE BUTTONS ==================
  function renderPaletteButtons() {
    const container = document.getElementById('paletteButtons');
    container.innerHTML = '';
    Object.keys(colorPalettes).forEach(palette => {
      const btn = document.createElement('button');
      btn.className = `palette-btn ${currentPalette === palette ? 'active' : ''}`;
      btn.textContent = palette.charAt(0).toUpperCase() + palette.slice(1);
      btn.onclick = () => {
        currentPalette = palette;
        renderPaletteButtons();
        renderColorGrid();
      };
      container.appendChild(btn);
    });
  }

  // ================== COLOR GRID ==================
  function renderColorGrid() {
    const container = document.getElementById('colorGrid');
    container.innerHTML = '';
    colorPalettes[currentPalette].forEach(color => {
      const btn = document.createElement('button');
      btn.className = `color-btn ${selectedColor === color ? 'active' : ''}`;
      btn.style.backgroundColor = color;
      btn.onclick = () => {
        selectedColor = color;
        updateSelectedColor();
        renderColorGrid();
        renderQuickColors();
      };
      container.appendChild(btn);
    });
  }

  // ================== QUICK COLORS ==================
  function renderQuickColors() {
    const container = document.getElementById('quickColors');
    container.innerHTML = '';
    const quickColors = ['#FF0000', '#FFA500', '#FFFF00', '#00FF00', '#0000FF', '#FF00FF'];
    quickColors.forEach(color => {
      const btn = document.createElement('button');
      btn.className = `quick-color-btn ${selectedColor === color ? 'active' : ''}`;
      btn.style.backgroundColor = color;
      btn.onclick = () => {
        selectedColor = color;
        updateSelectedColor();
        renderColorGrid();
        renderQuickColors();
      };
      container.appendChild(btn);
    });
  }

  // ================== ANSWERS ==================
  function renderAnswerButtons() {
    const container = document.getElementById('answerGrid');
    container.innerHTML = '';
    const answers = flyingOptions[currentNumber] || [];
    answers.forEach((answer, index) => {
      const btn = document.createElement('button');
      btn.className = 'answer-btn';
      btn.textContent = answer;
      btn.onclick = () => handleAnswerClick(index);
      if (feedback[index] !== undefined && feedback[index] !== null) {
        btn.classList.add(feedback[index] ? 'correct' : 'incorrect');
      }
      container.appendChild(btn);
    });
  }

  function handleAnswerClick(answerIndex) {
    const isCorrect = true; // placeholder â€” implement real logic if needed
    feedback[answerIndex] = isCorrect;
    renderAnswerButtons();
    setTimeout(() => {
      feedback[answerIndex] = null;
      renderAnswerButtons();
    }, 1500);
  }

  // ================== NEXT LEVEL ==================
  function handleNextLevel() {
    currentNumber++;
    if (currentNumber >= Object.keys(svgPaths).length) currentNumber = 0;
    fillProgress = 0;
    // clean up old click handler if any
    if (currentSvgElement && currentSvgClickHandler) {
      currentSvgElement.removeEventListener('click', currentSvgClickHandler);
      currentSvgClickHandler = null;
    }
    currentSvgElement = null;
    updateCenterSvg();
    renderAnswerButtons();
  }

  // ================== LOAD SVG WITH PROGRESSIVE FILL ==================
  function updateCenterSvg() {
    const container = document.getElementById('customSvgContainer');
    container.innerHTML = '';

    const svgPath = svgPaths[currentNumber];
    if (!svgPath) {
      container.textContent = currentNumber;
      return;
    }

    fetch(svgPath)
      .then(response => {
        if (!response.ok) throw new Error('SVG load error');
        return response.text();
      })
      .then(svgString => {
        // parse string into DOM
        const temp = document.createElement('div');
        temp.innerHTML = svgString.trim();
        const svgElement = temp.querySelector('svg');

        if (!svgElement) throw new Error('No SVG element found');

        // remove any width/height inline attributes to make responsive
        svgElement.removeAttribute('width');
        svgElement.removeAttribute('height');

        // store reference
        currentSvgElement = svgElement;

        // style wrapper
        svgElement.style.width = '100%';
        svgElement.style.height = '100%';
        svgElement.style.display = 'block';
        svgElement.style.maxWidth = '480px';
        svgElement.style.margin = '0 auto';
        svgElement.style.cursor = 'pointer';
        svgElement.style.transition = 'transform 0.18s ease';

        // ensure defs & gradient stops exist and shapes are filled by gradient
        applyFillEffect(svgElement);

        // click handler
        currentSvgClickHandler = () => {
          fillProgress++;
          if (fillProgress > fillSteps) fillProgress = fillSteps;
          updateSvgFill(svgElement, fillProgress);

          // subtle pop animation
          svgElement.style.transform = 'scale(1.05)';
          setTimeout(() => svgElement.style.transform = 'scale(1)', 180);
        };
        svgElement.addEventListener('click', currentSvgClickHandler);

// append to DOM (inline)
container.appendChild(svgElement);

// apply color to fillable SVG (like zero-fillable.svg)
if (svgElement.id === 'zero-svg') {
  svgElement.style.color = selectedColor;
}

// initial fill state
updateSvgFill(svgElement, fillProgress);
      })
      .catch(err => {
        console.error(err);
        const placeholder = document.createElement('div');
        placeholder.style.cssText = 'width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:72px;color:#cbd5e0';
        placeholder.textContent = currentNumber;
        container.appendChild(placeholder);
      });
  }

  // ================== APPLY FILL EFFECT ==================
  function applyFillEffect(svgElement) {
    // ensure defs
    let defs = svgElement.querySelector('defs');
    if (!defs) {
      defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
      svgElement.insertBefore(defs, svgElement.firstChild);
    } else {
      // remove existing gradients that might conflict for safety
      // (keep other defs if needed)
      const existing = defs.querySelectorAll(`#fillGradient-${currentNumber}, #fillColorStop-${currentNumber}, #fillEmptyStop-${currentNumber}`);
      existing.forEach(n => n.remove());
    }

    // create gradient
    const gradient = document.createElementNS('http://www.w3.org/2000/svg','linearGradient');
    gradient.setAttribute('id', `fillGradient-${currentNumber}`);
    gradient.setAttribute('x1','0%'); gradient.setAttribute('y1','100%');
    gradient.setAttribute('x2','0%'); gradient.setAttribute('y2','0%');

    // two stops placed at same offset â€” updateSvgFill will move offsets
    const stop1 = document.createElementNS('http://www.w3.org/2000/svg','stop');
    stop1.setAttribute('id', `fillColorStop-${currentNumber}`);
    stop1.setAttribute('offset', '0%');
    stop1.setAttribute('stop-color', selectedColor);

    const stop2 = document.createElementNS('http://www.w3.org/2000/svg','stop');
    stop2.setAttribute('id', `fillEmptyStop-${currentNumber}`);
    stop2.setAttribute('offset', '0%');
    stop2.setAttribute('stop-color', '#f1f5f9');

    gradient.appendChild(stop1);
    gradient.appendChild(stop2);
    defs.appendChild(gradient);

    // apply gradient fill to shapes that can be filled
    // include path/rect/circle/ellipse/polygon
    const shapes = svgElement.querySelectorAll('path, rect, circle, ellipse, polygon, polyline');
    shapes.forEach(shape => {
      // override fill even if original had fill="none"
      shape.setAttribute('fill', `url(#fillGradient-${currentNumber})`);
      // remove stroke if you don't want outlines; comment next two lines if you want stroke
      shape.setAttribute('stroke', 'none');
    });
  }

  // ================== UPDATE SVG FILL ==================
  function updateSvgFill(svgElement, progress) {
    const percentage = Math.round((progress / fillSteps) * 100);
    const fillStop = svgElement.querySelector(`#fillColorStop-${currentNumber}`);
    const emptyStop = svgElement.querySelector(`#fillEmptyStop-${currentNumber}`);

    if (fillStop && emptyStop) {
      // set color and offsets â€” below offset is colored, above is empty
      fillStop.setAttribute('stop-color', selectedColor);
      fillStop.setAttribute('offset', `${percentage}%`);
      emptyStop.setAttribute('offset', `${percentage}%`);
    }
  }

  // ================== RESET GAME ==================
  function resetGame() {
    feedback = {};
    currentNumber = 0;
    fillProgress = 0;
    if (currentSvgElement && currentSvgClickHandler) {
      currentSvgElement.removeEventListener('click', currentSvgClickHandler);
      currentSvgClickHandler = null;
    }
    currentSvgElement = null;
    updateCenterSvg();
    renderAnswerButtons();
    updateSelectedColor();
  }

  // initialize after DOM
  window.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
